<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>実装 on 1ミリもわからん</title><link>https://raahii.github.io/tags/%E5%AE%9F%E8%A3%85/</link><description>Recent content in 実装 on 1ミリもわからん</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><lastBuildDate>Mon, 09 Oct 2017 01:32:00 +0900</lastBuildDate><atom:link href="https://raahii.github.io/tags/%E5%AE%9F%E8%A3%85/index.xml" rel="self" type="application/rss+xml"/><item><title>3Dオブジェクト（ボクセルデータ）を描画するツールを作った</title><link>https://raahii.github.io/2017/10/09/voxel/</link><pubDate>Mon, 09 Oct 2017 01:32:00 +0900</pubDate><guid>https://raahii.github.io/2017/10/09/voxel/</guid><description>最近、GANで3Dオブジェクトを生成する論文を読んでいました。下のスライドは雑なまとめなのですが、前者が所謂3D-GANと呼ばれている論文で初めて3Dオブジェクトの生成にGANを適用した論文です。後者はその3D-GANを応用した研究のようです。
どんなものか知るには著者らが公開している動画が非常にわかりやすいです。静止画と同じようにGANを3Dモデルにも適用できそうだということがわかります。
ということでgithubにあがっている実装などを参考に実際にやろうとしているところなのですが、これらの手法では主に3Dオブジェクトを「ボクセル」として扱っています。
このボクセルというのは「体積 (volume)」と「ピクセル (pixel)」を組み合わせたかばん語らしいのですが、要は画像と同じ要領で3Dモデルを3次元配列に格納して表したものです。イメージとしてはマインクラフトみたいな感じです。
CGでは頂点情報や法線、テクスチャなどを保存する.obj, .3dsなどが有名（らしい）ですが、それらに比べると非常に簡単で取り扱いやすくなっています。
その一方でボクセルデータを保存する形式には.binvoxがあるのですが、メジャーではないためかツールが少なめです（まぁただの3次元配列だしね…）。ざっくり探したところ以下のものは便利そうだなと思いました。
.binvoxを3次元配列に変換: dimatura/binvox-rw-py(python)
.objや.mtlを読み込んで変換し、ボクセルとして可視化: Online Voxelizer(web)
ただ、単に.binvoxファイルをアップロードしてすぐに中身を見れるツールはなさそうだったので今回はそれを作ってみました（というエントリです）。ここから試せます。
github.com
ボクセルは形式そのものがシンプルなのでmatplotlibを使って3dplotするのでも良いのですが、結構重いんですよね。three.jsを使えばWeb上でマウスでグリグリできるインターフェースを簡単に作れるので楽しいですし、いつかフロントエンドで使えるかも…。
先程紹介したOnline Voxelizerに比べると動作がかなり遅いしメモリも結構消費してしまうのでそこが今後の課題です。うーん…おしまい。</description></item><item><title>Chrome extensionに入門した</title><link>https://raahii.github.io/2016/08/12/002118/</link><pubDate>Fri, 12 Aug 2016 00:21:00 +0900</pubDate><guid>https://raahii.github.io/2016/08/12/002118/</guid><description>http://dotinstall.com/lessons/basic_chrome_v2dotinstall.com
前回の記事でスターをつけてくださった方のブログを眺めていたらChromeの拡張機能を作っていて、Chromeの拡張機能ってHTML/CSS/JSだけで作れるのか！ということを知りました。せっかくの機会なので入門して自分なりに簡単な拡張機能を作ってみました。
モチベーション シンプルにChromeを使っていて不便だと思う部分を解決するために作りました。
私の考える問題点 例えば、Chromeでブラウジングしていて、最初はあることについて調べていたんだけど、気づいたら全く違うテーマのページを開いていた、なんてことありませんか？特に自分は学校の課題で調べ事してたんだけど退屈すぎていつの間にかネットサーフィンしてた、みたいなのがよくあります。
そんな時、そのウィンドウには、もともと調べていたテーマに関するタブと、新しく調べ始めたテーマに関するタブが混在してしまっている状態です。こういう時、テーマによってウィンドウを分けたくなります。そんなときみなさんどうしますか？単純にやるとこう↓なりませんか。
（左側3つのタブと右側2つのタブを切り分ける様子）
このようにブラウザって複数のタブに対してはあまり柔軟に操作できないなと感じます。とくにウィンドウをまたぐと辛い。そこでタブ（ウィンドウ）操作を柔軟にする拡張機能をつくりました。 つくったもの github.com
　そのような流れでChrome拡張機能の入門として↑を作りました。インポートすると右上にタブっぽいアイコンが出てきますので、これをクリックすると使うことができます。この拡張機能は、タブのかたまりに対して主に分割する機能（split）と、保存する機能（store、bookmark）で合計3つの機能を備えています。
split: 現在開いているタブを含め右側のタブを新しいウィンドウで開く
一つのウィンドウに存在する異なるテーマのタブ群を分割(split)します。splitボタンを押すと、今開いている(activeな)タブを含め、そこから右側にあるタブを新しいウィンドウで開きます。
store: 今開いているウィンドウをWebStorageに一時保存
保存したいタブ群をまずsplitで切り出した後に、保存したいウィンドウでstoreボタンを押すとあなたのlocalStorageにウィンドウが保存されます。
他のデバイスで見たりするわけじゃないけど、少しの間しまっておきたい時に使います。取り出すときは、先ほどのstoreボタンがretrieveボタンになっているのでそれを押して下さい。
bookmark: 今開いているウィンドウのタブを全てブックマークする
store機能は使っている端末のlocalStorageに保存するので、他の端末では開くことができません。もちろんスマホのChromeでは拡張機能自体が使えないので共有できません。そんなとき今開いているウィンドウの全てのタブを一括ブックマークできるのがbookmarkボタンです。
bookmarkボタンを押すとパスの設定画面が現れます。新しいフォルダ名とそのフォルダをどこに置くかを決めてsaveボタンを押してください。もしフォルダ名が空であった場合、新しくフォルダは作らずそのまま展開してブックマークされます。
課題 store機能の改善
保持したウィンドウの情報を見れる機能、もう要らないって場合に捨てられる機能があったらよいかも。
splitできるならjoinも？
splitの逆で複数のwindowを1つにまとめられる機能があってもよいかも。
バグの修正
初回のウィンドウに限ってsplitがうまく動かない時がある。 jsの非同期処理による弊害をあんまり考慮せず作ったのでそのあたりを見直したい。 popup.htmlを改良する
最低限のデザインにしていきたいんだけど、レイアウトの仕方について要勉強。この手のページを作るとき、大体HTML/CSSを書くのにJavaScriptと同じくらい時間かかるのもどうにかしたい。 名前
tabs_splitterなんかしっくりこない。英語的にもおかしい気がするしtabをキーワードとして残したい。
所感 ボタンの名前をどう表記するのがベスト？
単に split？それとももっと詳しく open right tabs in a new window？あるいは日本語で ◯◯◯？どれがわかりやすいんだろう。</description></item><item><title>Google Maps APIを使った標高の可視化</title><link>https://raahii.github.io/2016/07/24/155027/</link><pubDate>Sun, 24 Jul 2016 15:50:00 +0900</pubDate><guid>https://raahii.github.io/2016/07/24/155027/</guid><description>タイトルの通りGoogle Maps APIを使って、出発地点から目的地点までの高低差を可視化する簡単なサイトを作ってみました。
ルートに沿った標高の可視化
github.com
きっかけとしては、新生活に伴い、家から大学までのルートの高低差を知りたかったからです。
個人的な話ですが、今年から大学に進学しまして一人暮らしを始めました。一人暮らしにあたっては家賃はもちろんですが、家から学校までの距離が一つ重要な要素ですよね。近いに越したことはないとは思いますが、スーパーやコンビニのあるなしで利便性が大きく変わるので、少々遠くても自転車で通えればOKです。まぁ10km前後になると夏は汗だくで授業を受けるはめになりますが...。
そんなとき、加えて重要なのが、高低差じゃないでしょうか。アップダウンが激しいと辛いですよね。そんな具合で春頃に実際にそれを調べたいなと思った時、何故かそういうサービスがあまりなかったのでGoogle Maps APIを使って自分で作って可視化してみてました。
最近ではロードバイクやクロスバイクに乗る人が増えて、ランニングする人も多くなってきているので、結構使いたい人はいるんじゃないかと思っています。元々自分なりに春先には作っていたものを綺麗にしてWebサイト作りの練習として公開してみました。とはいってもHTML/CSS/JSだけの本当に簡単な試作品のレベルですが。
先ほど言ったとおり、このサイトではGoogle Maps APIを使っていて、出発地と目的地を入力すると自動でルート検索が行われて、ルートに沿った高低差が可視化されます。もともとそういう関数があるのでものすごく実装は簡単なんですが、ルートにそって高低差が出せるってとこが重要です。APIは無料で使う分にはup to 25,000 map loads per dayなのでサービスとしてはちゃんとしたものはできていませんが、今後ルートの候補を選べるようにしたり、ルートごとの高低差の違いを同時に見れたりしたら便利かなと思っています。
とまぁ、そんなこんなで最近はWeb系に興味がでてきたので、夏に集中的に勉強できたらなと思います。制作実績がないとインターンも厳しいので、コツコツ夏に勉強して冬のインターンを狙っていきたいと思います。それでは。
今よくよく探してみると、
地図検索 - NAVITIME
ルートラボ - LatLongLab
Flattest Route
と、機能や完成度・他サービスとの連携はまちまちですが既存のものも意外にありますね。(笑)
NAVITIMEは坂の少ない／多いルートを選べ、かつ所要時間も出ていて素晴らしいです。ただちょっと図が小さめ。ルートラボはパッと検索するというよりは、ユーザー同士が作ったルートをシェアできる機能があって独特なサービスです。Flattest Routeはなんか動かない。とはいえ、今回の題材はコンセプトとしては意外と悪くなかったかなと思います。</description></item><item><title>Pythonの日本語文字列</title><link>https://raahii.github.io/2015/06/28/211051/</link><pubDate>Sun, 28 Jun 2015 21:10:00 +0900</pubDate><guid>https://raahii.github.io/2015/06/28/211051/</guid><description>「研究者流コーディングの極意」を読んで、なんだかためになりそうだし、面白そうだし、ということで言語処理100本ノックを始めてみました。そして2つ目で詰まった(早い)。
使っている言語はPythonで、使い始めたばかりなのですが、そもそもプログラミングがダメダメです。
まず、その問題ですが、
&amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt;01. 「パタトクカシーー」&amp;lt;br&amp;gt; 「パタトクカシーー」という文字列の1,3,5,7文字目を取り出して連結した文字列を得よ．
&amp;lt;/blockquote&amp;gt; です。
まず私が考えたのは、こんな感じです。なんの疑問もなくこれでいけるだろうと思ってました笑。
string=&amp;ldquo;パタトクカシーー&amp;rdquo; rev=&amp;ldquo;&amp;rdquo; for i in [1,3,5,7]: rev+=string[i] print rev
一方結果は、
% python 01.「パタトクカシーー」.py �㿃 なんか文字化けしてる…。
それもそのはずで、「パタトクカシーー」は全て全角文字なのでひとひねり必要です。一般に半角は1byte、全角は2byteに符号化されているので、配列のお部屋と1:1対応にならないのが原因。
そしてPythonの場合、通常のstr型の全角文字は3byteに符号化されている（お部屋3つに対応している）みたいです。
&amp;gt;&amp;gt;&amp;gt; &amp;lsquo;あ&amp;rsquo;[0] &amp;lsquo;\xe3&amp;rsquo; &amp;gt;&amp;gt;&amp;gt; &amp;lsquo;あ&amp;rsquo;[1] &amp;lsquo;\x81&amp;rsquo; &amp;gt;&amp;gt;&amp;gt; &amp;lsquo;あ&amp;rsquo;[2] &amp;lsquo;\x82&amp;rsquo; &amp;gt;&amp;gt;&amp;gt; &amp;lsquo;あ&amp;rsquo;[3] Traceback (most recent call last): File &amp;ldquo;&amp;lt;stdin&amp;gt;&amp;rdquo;, line 1, in &amp;lt;module&amp;gt; IndexError: string index out of range この記事が参考になりました。qiita.com
これを知ったうえで愚直に書き換えると、
string=&amp;ldquo;パタトクカシーー&amp;rdquo; rev=&amp;ldquo;&amp;rdquo; for i in [1,3,5,7]: for j in range(3):#全角なので rev+=string[3*i+j] print rev</description></item></channel></rss>